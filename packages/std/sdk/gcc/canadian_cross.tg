/** This package takes a bootstrap C/C++ compiler and some utilities and canadian-crosses up a sizzling plate of farm-fresh GCC. The output of this package can then be used to build other compilers like LLVM. */

import * as bootstrap from "../../bootstrap.tg";
import * as std from "../../tangram.tg";
import binutils from "../binutils.tg";
import * as dependencies from "../dependencies.tg";
import * as gcc from "../gcc.tg";
import * as proxy from "../proxy.tg";

export let toolchain = tg.target(async (arg?: std.Triple.HostArg) => {
	let host = await std.Triple.host(arg);
	let build = bootstrap.toolchainTriple(host);

	let sdk = { bootstrapMode: true };

	// Ensure the dependencies are built.
	await dependencies.env({ host, sdk });

	// Stage 1: Produce build -> host cross-compiler.
	let { env, sysroot } = await buildToHostCrossToolchain({
		build,
		host,
		sdk,
	});

	// Stage 2: Produce host -> target compiler.
	let hostToTargetToolchain = nativeHostToolchain({
		env,
		host,
		sysroot,
	});

	return hostToTargetToolchain;
});

export let buildToHostCrossToolchain = tg.target(
	async (arg?: std.sdk.BuildEnvArg) => {
		let { build: build_, host: host_, ...rest } = arg ?? {};

		let build = build_ ? std.triple(build_) : await std.Triple.host();
		let host = build;
		let target = host_ ? std.triple(host_) : host;

		return gcc.crossToolchain({
			...rest,
			build,
			host,
			target,
			variant: "stage1_limited",
		});
	},
);

type NativeHostToolchainArg = {
	env: std.env.Arg;
	host: std.Triple;
	sysroot: tg.Directory;
};

export let nativeHostToolchain = tg.target(
	async (arg: NativeHostToolchainArg) => {
		let build = bootstrap.toolchainTriple(arg.host);
		let { env, host, sysroot } = arg;
		let target = host;
		let sdk = { bootstrapMode: true };

		let nativeHostBinutils = await binutils({
			env,
			build,
			host,
			sdk,
			staticBuild: true,
			target,
		});
		nativeHostBinutils = await bootstrap.sdk.prefixBins(
			nativeHostBinutils,
			[
				"addr2line",
				"ar",
				"as",
				"ld",
				"nm",
				"objcopy",
				"objdump",
				"ranlib",
				"readelf",
				"strip",
				"strings",
			],
			std.Triple.toString(host) + "-",
		);
		console.log("stage2 binutils", await nativeHostBinutils.id());

		let fullGCC = await gcc.build({
			binutils: nativeHostBinutils,
			build,
			env,
			host,
			sdk,
			sysroot,
			target,
			variant: "stage2_full",
		});
		console.log("stage2 gcc", await fullGCC.id());

		// Return just the directory.
		return fullGCC;
	},
);

export let testStage1 = async () => {
	let host = await std.Triple.host();
	let build = bootstrap.toolchainTriple(host);
	let { env } = await buildToHostCrossToolchain({
		build,
		host,
		sdk: { bootstrapMode: true },
	});
	await std.sdk.assertValid(env, { host: build, target: host });
	return true;
};

export let testCanadianCross = async () => {
	let toolchainDir = await toolchain();
	return toolchainDir;
};
