import * as bootstrap from "../bootstrap.tg";
import * as std from "../tangram.tg";

export let metadata = {
	homepage: "https://www.kernel.org",
	license: "GPLv2",
	name: "linux",
	repository: "https://git.kernel.org",
	version: "6.1.66",
};

export let source = tg.target(async () => {
	let { name, version } = metadata;
	let checksum =
		"sha256:419e62cd6c4239e6950b688db9e8753eb1e99c216dc3204f7932398a3fef1a0c";
	let unpackFormat = ".tar.xz" as const;
	let url = `https://cdn.kernel.org/pub/linux/kernel/v6.x/${name}-${version}${unpackFormat}`;
	let source = tg.Directory.expect(
		await std.download({ url, checksum, unpackFormat }),
	);
	return std.directory.unwrap(source);
});

type Arg = std.sdk.BuildEnvArg & {
	phases?: tg.MaybeNestedArray<std.phases.Arg>;
	source?: tg.Directory;
};

export let kernelHeaders = tg.target(async (arg?: Arg) => {
	let {
		build: build_,
		host: host_,
		phases: phasesArg = [],
		source: source_,
		...rest
	} = arg ?? {};
	let host = host_ ? std.triple(host_) : await std.Triple.host();
	let buildTriple = build_ ? std.triple(build_) : host;
	tg.assert(
		std.Triple.eq(buildTriple, host),
		"Cross-compiling the Linux headers is currently unsupported.",
	);

	let system = std.Triple.system(host);

	let sourceDir = source_ ?? source();

	tg.assert(
		tg.System.os(system) === "linux",
		"The Linux kernel headers can only be built on Linux.",
	);

	// NOTE - the kernel build wants the string x86_64 on x86_64 but arm64 on aarch64.
	let tripleArch = host.arch;
	let karch = tripleArch.toString();
	if (karch === "aarch64") {
		karch = "arm64";
	}

	// The kernel headers always use the musl-based bootstrap toolchain.
	let buildToolchain = await bootstrap.toolchain({ host });
	let buildLibPath = tg`${buildToolchain}/lib`;
	let ccFlags = tg`-Wl,-dynamic-linker,${buildLibPath}/${bootstrap.interpreterName(
		host,
	)} -Wl,-rpath,${buildLibPath}`;
	let env = [
		bootstrap.toolchainEnv({ host }),
		bootstrap.make.build({ host }),
		std.utils.env({ ...rest, host, sdk: { bootstrapMode: true } }),
		{
			CC: tg`gcc ${ccFlags}`,
		},
	];

	let prepare = tg`cp -r ${sourceDir}/* . && chmod -R +w . && make mrproper`;
	let build = {
		body: `make ARCH=${karch} HOSTCC="\$CC" headers`,
		post: "find usr/include -type f ! -name '*.h' -delete",
	};
	let install = {
		pre: "mkdir -p $OUTPUT",
		body: `cp -r usr/include/. $OUTPUT && mkdir -p $OUTPUT/config && echo ${metadata.version}-default > $OUTPUT/config/kernel.release`,
	};
	let order = ["prepare", "build", "install"];

	let result = tg.Directory.expect(
		await std.phases.build(
			{
				env,
				phases: { prepare, build, install },
				order,
				target: { host: std.Triple.system(host) },
			},
			phasesArg,
		),
	);

	return result;
});

export default kernelHeaders;

export let test = tg.target(async () => {
	let system = await std.Triple.hostSystem();
	if (tg.System.os(system) !== "linux") {
		return;
	}
	let headers = await kernelHeaders();
	let configFile = tg.File.expect(await headers.get("config/kernel.release"));
	let configFileContents = (await configFile.text()).trim();
	tg.assert(configFileContents === `${metadata.version}-default`);
	let kernelH = tg.File.expect(await headers.get("linux/kernel.h"));
	let kernelHContents = await kernelH.text();
	tg.assert(kernelHContents.includes("#ifndef _LINUX_KERNEL_H"));
	return true;
});
