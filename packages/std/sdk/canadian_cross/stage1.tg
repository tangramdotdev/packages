/** Stage 1: Ingredients. To produce a compiler with `build != host`, we must first produce a cross-compiler from `build` to `host`. */

import * as bootstrap from "../../bootstrap.tg";
import * as std from "../../tangram.tg";
import binutils from "../binutils.tg";
import * as dependencies from "../dependencies.tg";
import gcc from "../gcc.tg";
import kernelHeaders from "../kernel_headers.tg";
import { constructSysroot } from "../libc.tg";
import * as proxy from "../proxy.tg";

type Arg = std.sdk.BuildEnvArg;

export let buildToHostCrossToolchain = tg.target(async (arg?: Arg) => {
	let { build: build_, env: env_, host: host_, ...rest } = arg ?? {};
	let build = bootstrap.toolchainTriple(build_ ?? (await std.Triple.host()));

	let host = build;
	let target = host_ ? std.triple(host_) : host;

	// Produce the binutils.
	let buildToHostBinutils = await binutils({ ...rest, build, host, target });
	console.log("buildToHostBinutils", await buildToHostBinutils.id());

	// Produce the linux headers.
	let linuxHeaders = await tg.directory({
		include: await kernelHeaders({ host: target }),
	});
	console.log("linuxHeaders", await linuxHeaders.id());

	let linuxHeadersSysroot = await tg.directory({
		[std.Triple.toString(target)]: linuxHeaders,
	});

	// Produce the initial gcc required to build the standard C library.
	let bootstrapGCC = await gcc({
		...rest,
		binutils: buildToHostBinutils,
		build,
		host,
		sysroot: linuxHeadersSysroot,
		target,
		variant: "stage1_bootstrap",
	});
	console.log("bootstrapGCC", await bootstrapGCC.id());

	// Produce a combined directory contianing the correct C library for the host and the Linux headers.
	let sysroot = await constructSysroot({
		...rest,
		linuxHeaders,
		env: bootstrapGCC,
		target,
	});
	console.log("hostSysroot", await sysroot.id());

	// Produce a toolchain containing the sysroot and a cross-compiler.
	let crossGCC = await gcc({
		...rest,
		binutils: buildToHostBinutils,
		build,
		host,
		sysroot,
		target,
		variant: "stage1_limited",
	});
	console.log("cross gcc", await crossGCC.id());

	// Produce a cross-proxy env.
	let crossProxy = await proxy.env({
		env: crossGCC,
		host: build,
		target: host,
	});

	return { env: [crossGCC, crossProxy], sysroot };
});

export let test = async () => {
	let host = await std.Triple.host();
	let buildSDK = await std.sdk.bootstrap({ host });
	let utilsEnv = await dependencies.env({ sdk: { bootstrapMode: true } });
	let build = std.triple(bootstrap.toolchainTriple(host));
	let { env } = await buildToHostCrossToolchain({
		env: [buildSDK, utilsEnv],
		host,
	});
	await std.sdk.assertValid(env, { host: build, target: host });
	return true;
};
