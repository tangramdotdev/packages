import * as std from "std" with { path: "../std" };
import { $ } from "std" with { path: "../std" };

import autoconf from "autoconf" with { path: "../autoconf" };
import automake from "automake" with { path: "../automake" };

import * as autotools from "./autotools";
import * as cc from "./cc";
import * as cmake from "./cmake";
import * as go from "./go";
import * as js from "./js";
import * as python from "./python";
import * as ruby from "./ruby";
import * as rust from "./rust";
import * as ts from "./ts";

import ccAutotoolsTest from "./tests/cc-autotools" with { type: "directory" };
import cPlainTest from "./tests/c-plain" with { type: "directory" };
import cxxPlainTest from "./tests/cxx-plain" with { type: "directory" };
import fortranPlainTest from "./tests/fortran-plain" with { type: "directory" };
import cmakeTest from "./tests/cmake" with { type: "directory" };
import goTest from "./tests/go" with { type: "directory" };
import jsNodeTest from "./tests/js-node" with { type: "directory" };
import jsPlainTest from "./tests/js-plain" with { type: "directory" };
import pythonTest from "./tests/python" with { type: "directory" };
import pythonPlainTest from "./tests/python-plain" with { type: "directory" };
import pythonPoetryTest from "./tests/python-poetry" with { type: "directory" };
import pythonPyprojectTest from "./tests/python-pyproject" with {
	type: "directory",
};
import rubyGemTest from "./tests/ruby-gem" with { type: "directory" };
import rubyPlainTest from "./tests/ruby-plain" with { type: "directory" };
import rustCargoTest from "./tests/rust-cargo" with { type: "directory" };
import rustPlainTest from "./tests/rust-plain" with { type: "directory" };
import tsPlainTest from "./tests/ts-plain" with { type: "directory" };

export const metadata = {
	name: "autobuild",
	version: "0.0.0",
};

export type Arg = {
	build?: string;
	env?: std.env.Arg;
	kind?: Kind;
	host?: string;
	source: tg.Directory;
};

export const build = tg.target(async (arg: Arg) => {
	const { env: envArg, source } = arg;
	const sourceId = await source.id();
	console.log("received source dir", sourceId);
	const kind = await detectKind(source);

	// Usually the env is passed in because the module generated by `tangram init` does so explicitly. If it was not set, we should provide it ourselves.
	let env_ = envArg ?? env({ source });

	let arg_ = { ...arg, env: env_ };

	switch (kind) {
		case "cc-autotools": {
			return autotools.build(arg_);
		}
		case "c-plain": {
			return cc.c(arg_);
		}
		case "cxx-plain": {
			return cc.cxx(arg_);
		}
		case "fortran-plain": {
			return cc.fortran(arg_);
		}
		case "cmake": {
			return cmake.build(arg_);
		}
		case "go": {
			return go.build(arg_);
		}
		case "js-node": {
			return js.node(arg_);
		}
		case "js-plain": {
			return js.plain(arg_);
		}
		case "python": {
			return python.build(arg_);
		}
		case "python-plain": {
			return python.plain(arg_);
		}
		case "python-poetry": {
			return python.poetry(arg_);
		}
		case "python-pyproject": {
			return python.pyproject(arg_);
		}
		case "ruby-gem": {
			return ruby.gem(arg_);
		}
		case "ruby-plain": {
			return ruby.plain(arg_);
		}
		case "rust-cargo": {
			return rust.cargo(arg_);
		}
		case "rust-plain": {
			return rust.plain(arg_);
		}
		case "ts": {
			ts.build(arg_);
		}
		case "ts-plain": {
			ts.plain(arg_);
		}
		default: {
			throw new Error(
				`unable to autodetect project type, edit your tangram.ts file to define desired behavior`,
			);
		}
	}
});

export default build;

export type EnvArg = {
	build?: string | undefined;
	host?: string | undefined;
	source: tg.Directory;
};

export const env = tg.target(async (arg: EnvArg) => {
	const { build, host, source } = arg;
	const sourceId = await source.id();
	console.log("received source dir", sourceId);
	const kind = await detectKind(source);

	const arg_ = { build, host };

	switch (kind) {
		case "cc-autotools": {
			return autotools.env(arg_);
		}
		case "c-plain":
		case "cxx-plain":
		case "fortran-plain": {
			return cc.env(arg_);
		}
		case "cmake": {
			return cmake.env(arg_);
		}
		case "go": {
			return go.env(arg_);
		}
		case "js-node":
		case "js-plain": {
			return js.env(arg_);
		}
		case "python":
		case "python-plain":
		case "python-poetry":
		case "python-pyproject": {
			return python.env(arg_);
		}
		case "ruby-gem":
		case "ruby-plain": {
			return ruby.env(arg_);
		}
		case "rust-cargo":
		case "rust-plain": {
			return rust.env(arg_);
		}
		case "ts":
		case "ts-plain": {
			return ts.env(arg_);
		}
		default: {
			throw new Error(
				`unable to autodetect project type, edit your tangram.ts file to define desired behavior`,
			);
		}
	}
});

export type Kind =
	| "cc-autotools"
	| "c-plain"
	| "cxx-plain"
	| "fortran-plain"
	| "cmake"
	| "go"
	| "js-node"
	| "js-plain"
	| "python"
	| "python-plain"
	| "python-poetry"
	| "python-pyproject"
	| "ruby-gem"
	| "ruby-plain"
	| "rust-cargo"
	| "rust-plain"
	| "ts"
	| "ts-plain";

export const detectKind = async (source: tg.Directory): Promise<Kind> => {
	const entries = await source.entries();
	const hasFile = (name: string) =>
		entries.hasOwnProperty(name) && entries[name] instanceof tg.File;
	const hasExecutableFile = (name: string) =>
		entries.hasOwnProperty(name) &&
		entries[name] instanceof tg.File &&
		entries[name].executable();
	const hasDir = (name: string) =>
		entries.hasOwnProperty(name) && entries[name] instanceof tg.Directory;
	const hasFileWithExtension = (ext: string) =>
		Object.entries(entries).some(
			([name, artifact]) => artifact instanceof tg.File && name.endsWith(ext),
		);

	if (hasFile("Cargo.toml")) return "rust-cargo";
	if (hasFile("CMakeLists.txt")) return "cmake";
	if (hasExecutableFile("configure") || hasFile("configure.ac"))
		return "cc-autotools";
	if (hasFile("package.json") && hasFileWithExtension(".ts")) return "ts";
	if (hasFile("package.json")) return "js-node";
	if (hasFile("poetry.lock")) return "python-poetry";
	if (hasFile("pyproject.toml")) return "python-pyproject";
	if (hasFile("setup.py") || hasFile("setup.cfg")) return "python";
	if (hasFile("go.mod") || hasDir("vendor")) return "go";
	if (hasFile("Gemfile")) return "ruby-gem";

	if (hasFileWithExtension(".rb")) return "ruby-plain";
	if (hasFileWithExtension(".rs")) return "rust-plain";
	if (hasFileWithExtension(".py")) return "python-plain";
	if (hasFileWithExtension(".js")) return "js-plain";
	if (hasFileWithExtension(".ts")) return "ts-plain";
	if (
		hasFileWithExtension(".f90") ||
		hasFileWithExtension(".f77") ||
		hasFileWithExtension(".f") ||
		hasFileWithExtension(".for")
	)
		return "fortran-plain";
	if (hasFileWithExtension(".cxx") || hasFileWithExtension(".cpp"))
		return "cxx-plain";
	if (hasFileWithExtension(".c")) return "c-plain";

	// We didn't match any known types.
	throw new Error("failed to detect project kind");
};

// TODO
// dir with no runnable files
// meson
// php
// dirs with multiple types of files

export const test = tg.target(async () => {
	const allKinds: Array<Kind> = [
		"cc-autotools",
		// "c-plain",
		// "cxx-plain",
		// "fortran-plain",
		"cmake",
		"go",
		// "js-node",// failed to creat target without host - phases.build issue?
		"js-plain",
		// "python", // failed to find pyproject.toml - why is it looking for pyproject.toml?
		// "python-plain",
		// "python-poetry",
		// "python-pyproject",
		// "ruby-gem",
		// "ruby-plain",
		"rust-cargo", // strip issue on macOS!
		// "rust-plain",
		// "ts-plain", // cannot detect project type?
	];
	await Promise.all(allKinds.map((variant) => testKind(variant)));

	return true;
});

type TestFnArg = {
	testFile: (buildOutput: tg.Directory) => Promise<tg.Template>;
	expectedStdout: string;
};

const defaultTestArg: TestFnArg = {
	testFile: (buildOutput: tg.Directory): Promise<tg.Template> =>
		tg`${buildOutput}/bin/test`,
	expectedStdout: "Hello, world!",
};

const testParamaters = (): Record<Kind, TestFnArg> => {
	return {
		"cc-autotools": defaultTestArg,
		"c-plain": defaultTestArg,
		"cxx-plain": defaultTestArg,
		"fortran-plain": defaultTestArg,
		cmake: defaultTestArg,
		go: {
			...defaultTestArg,
			testFile: (buildOutput: tg.Directory): Promise<tg.Template> =>
				tg`${buildOutput}/bin/hello`,
		},
		"js-node": defaultTestArg,
		"js-plain": {
			...defaultTestArg,
			testFile: (buildOutput: tg.Directory): Promise<tg.Template> =>
				tg`${buildOutput}/index.js`,
		},
		python: defaultTestArg,
		"python-plain": {
			...defaultTestArg,
			testFile: (buildOutput: tg.Directory): Promise<tg.Template> =>
				tg`${buildOutput}/main.py`,
		},
		"python-poetry": defaultTestArg,
		"python-pyproject": defaultTestArg,
		"ruby-gem": defaultTestArg,
		"ruby-plain": defaultTestArg,
		"rust-cargo": defaultTestArg,
		"rust-plain": defaultTestArg,
		ts: defaultTestArg,
		"ts-plain": defaultTestArg,
	};
};

const testDirs = async (): Promise<Record<Kind, tg.Directory>> => {
	const preparedAutotoolsTest = await prepareAutotoolsTestDistributionBundle();
	return {
		"cc-autotools": preparedAutotoolsTest,
		"c-plain": cPlainTest,
		"cxx-plain": cxxPlainTest,
		"fortran-plain": fortranPlainTest,
		cmake: cmakeTest,
		go: goTest,
		"js-node": jsNodeTest,
		"js-plain": jsPlainTest,
		python: pythonTest,
		"python-plain": pythonPlainTest,
		"python-poetry": pythonPoetryTest,
		"python-pyproject": pythonPyprojectTest,
		"ruby-gem": rubyGemTest,
		"ruby-plain": rubyPlainTest,
		"rust-cargo": rustCargoTest,
		"rust-plain": rustPlainTest,
		ts: tsPlainTest,
		"ts-plain": tsPlainTest,
	};
};

export const testKind = tg.target(async (kind: Kind) => {
	console.log(`testing ${kind}...`);
	const dirs = await testDirs();
	const source = dirs[kind];

	// Test detection
	console.log("source", await source.id());
	const detectedKind = await detectKind(source);
	tg.assert(detectedKind == kind, `expected ${kind}, got ${detectedKind}`);

	// Test build
	const buildOutput = await build({ source }).then(tg.Directory.expect);
	console.log("buildOutput", await buildOutput.id());
	const testStdout = async (arg: TestFnArg): Promise<boolean> => {
		const stdout = await $`${arg.testFile(buildOutput)} > $OUTPUT`
			.then(tg.File.expect)
			.then((t) => t.text())
			.then((t) => t.trim());
		tg.assert(stdout === arg.expectedStdout, `expected ${arg.expectedStdout}, received ${stdout}`);
		return true;
	};
	await testStdout(testParamaters()[kind]);
	return true;
});

/** We need to generate the distribution bundle for the `cc-autotools` test package, generating the configure scripts and intermediate makefile templates. */
export const prepareAutotoolsTestDistributionBundle = tg.target(async () => {
	const originalSource = ccAutotoolsTest;
	return $`set -eux
			cp -R ${originalSource} $OUTPUT
			chmod -R u+w $OUTPUT
			cd $OUTPUT
			autoreconf --install --verbose`
		.env(autoconf(), automake())
		.then(tg.Directory.expect);
});
