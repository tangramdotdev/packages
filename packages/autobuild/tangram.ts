import * as std from "std" with { local: "../std" };
import { $ } from "std" with { local: "../std" };

import * as autotools from "./autotools";
import * as cmake from "./cmake";
import * as go from "./go";
import * as js from "./js";
import * as python from "./python";
import * as ruby from "./ruby";
import * as rust from "./rust";

import ccAutotoolsTest from "./tests/cc-autotools" with { type: "directory" };
import cmakeTest from "./tests/cmake" with { type: "directory" };
import goTest from "./tests/go" with { type: "directory" };
import jsNodeTest from "./tests/js-node" with { type: "directory" };
import jsPlainTest from "./tests/js-plain" with { type: "directory" };
import pythonTest from "./tests/python" with { type: "directory" };
import pythonPlainTest from "./tests/python-plain" with { type: "directory" };
import pythonPyprojectTest from "./tests/python-pyproject" with {
	type: "directory",
};
import rubyPlainTest from "./tests/ruby-plain" with { type: "directory" };
import rustCargoTest from "./tests/rust-cargo" with { type: "directory" };
import rustPlainTest from "./tests/rust-plain" with { type: "directory" };

export const metadata = {
	name: "autobuild",
	version: "0.0.0",
};

export type Arg = {
	build?: string;
	env?: std.env.Arg;
	kind?: Kind;
	host?: string;
	source: tg.Directory;
};

export const build = async (unresolvedArg: tg.Unresolved<Arg>) => {
	const arg = await tg.resolve(unresolvedArg);
	const { env: envArg, source } = arg;
	const sourceId = source.id;
	console.log("received source dir", sourceId);
	const kind = await detectKind(source);

	// Usually the env is passed in because the module generated by `tangram init` does so explicitly. If it was not set, we should provide it ourselves.
	let env_ = envArg ?? env({ source });

	let arg_ = { ...arg, env: env_ };

	switch (kind) {
		case "cc-autotools": {
			return autotools.build(arg_);
		}
		case "cmake": {
			return cmake.build(arg_);
		}
		case "go": {
			return go.build(arg_);
		}
		case "js-node": {
			return js.node(arg_);
		}
		case "js-plain": {
			return js.plain(arg_);
		}
		case "python": {
			return python.build(arg_);
		}
		case "python-plain": {
			return python.plain(arg_);
		}
		case "python-pyproject": {
			return python.pyproject(arg_);
		}
		case "ruby-plain": {
			return ruby.plain(arg_);
		}
		case "rust-cargo": {
			return rust.cargo(arg_);
		}
		case "rust-plain": {
			return rust.plain(arg_);
		}
		default: {
			throw new Error(
				`unable to autodetect project type, edit your tangram.ts file to define desired behavior`,
			);
		}
	}
};

export default build;

export type EnvArg = {
	build?: string | undefined;
	host?: string | undefined;
	source: tg.Directory;
};

export const env = async (unresolvedArg: tg.Unresolved<EnvArg>) => {
	const arg = await tg.resolve(unresolvedArg);
	const { build, host, source } = arg;
	const sourceId = source.id;
	console.log("received source dir", sourceId);
	const kind = await detectKind(source);

	const arg_ = { build, host };

	switch (kind) {
		case "cc-autotools": {
			return autotools.env(arg_);
		}
		case "cmake": {
			return cmake.env(arg_);
		}
		case "go": {
			return go.env(arg_);
		}
		case "js-node":
		case "js-plain": {
			return js.env(arg_);
		}
		case "python":
		case "python-plain":
		case "python-pyproject": {
			return python.env(arg_);
		}
		case "ruby-plain": {
			return ruby.env(arg_);
		}
		case "rust-cargo":
		case "rust-plain": {
			return rust.env(arg_);
		}
		default: {
			throw new Error(
				`unable to autodetect project type, edit your tangram.ts file to define desired behavior`,
			);
		}
	}
};

export type Kind =
	| "cc-autotools"
	| "cmake"
	| "go"
	| "js-node"
	| "js-plain"
	| "python"
	| "python-plain"
	| "python-pyproject"
	| "ruby-plain"
	| "rust-cargo"
	| "rust-plain";

export const detectKind = async (source: tg.Directory): Promise<Kind> => {
	const entries = await source.entries();
	const hasFile = (name: string) =>
		entries.hasOwnProperty(name) && entries[name] instanceof tg.File;
	const hasExecutableFile = (name: string) =>
		entries.hasOwnProperty(name) &&
		entries[name] instanceof tg.File &&
		entries[name].executable();
	const hasDir = (name: string) =>
		entries.hasOwnProperty(name) && entries[name] instanceof tg.Directory;
	const hasFileWithExtension = (ext: string) =>
		Object.entries(entries).some(
			([name, artifact]) => artifact instanceof tg.File && name.endsWith(ext),
		);

	if (hasFile("Cargo.toml")) return "rust-cargo";
	if (hasFile("CMakeLists.txt")) return "cmake";
	if (hasExecutableFile("configure") || hasFile("configure.ac"))
		return "cc-autotools";
	if (hasFile("package.json")) return "js-node";
	if (hasFile("pyproject.toml")) return "python-pyproject";
	if (hasFile("setup.py") || hasFile("setup.cfg")) return "python";
	if (hasFile("go.mod") || hasDir("vendor")) return "go";

	if (hasFileWithExtension(".py")) return "python-plain";
	if (hasFileWithExtension(".rb")) return "ruby-plain";
	if (hasFileWithExtension(".rs")) return "rust-plain";
	if (hasFileWithExtension(".js")) return "js-plain";

	// We didn't match any known types.
	throw new Error("failed to detect project kind");
};

export const test = async () => {
	const allKinds: Array<Kind> = [
		"cc-autotools",
		"cmake",
		"go",
		"js-plain",
		"js-node",
		"python-plain",
		"ruby-plain",
		"rust-cargo",
		"rust-plain",
	];
	await Promise.all(allKinds.map((variant) => testKind(variant)));

	return true;
};

type TestFnArg = {
	testFile: (buildOutput: tg.Directory) => Promise<tg.Template>;
	expectedStdout: string;
};

const defaultTestArg: TestFnArg = {
	testFile: (buildOutput: tg.Directory): Promise<tg.Template> =>
		tg`${buildOutput}/bin/test`,
	expectedStdout: "Hello, world!",
};

const testParamaters = (): Record<Kind, TestFnArg> => {
	return {
		"cc-autotools": defaultTestArg,
		cmake: defaultTestArg,
		go: {
			...defaultTestArg,
			testFile: (buildOutput: tg.Directory): Promise<tg.Template> =>
				tg`${buildOutput}/bin/hello`,
		},
		"js-node": defaultTestArg,
		"js-plain": {
			...defaultTestArg,
			testFile: (buildOutput: tg.Directory): Promise<tg.Template> =>
				tg`${buildOutput}/index.js`,
		},
		python: defaultTestArg,
		"python-plain": {
			...defaultTestArg,
			testFile: (buildOutput: tg.Directory): Promise<tg.Template> =>
				tg`${buildOutput}/main.py`,
		},
		"python-pyproject": defaultTestArg,
		"ruby-plain": {
			...defaultTestArg,
			testFile: (buildOutput: tg.Directory): Promise<tg.Template> =>
				tg`${buildOutput}/main.rb`,
		},
		"rust-cargo": defaultTestArg,
		"rust-plain": {
			...defaultTestArg,
			testFile: (buildOutput: tg.Directory): Promise<tg.Template> =>
				tg`${buildOutput}/bin/main`,
		},
	};
};

const testDirs = async (): Promise<Record<Kind, tg.Directory>> => {
	return {
		"cc-autotools": ccAutotoolsTest,
		cmake: cmakeTest,
		go: goTest,
		"js-node": jsNodeTest,
		"js-plain": jsPlainTest,
		python: pythonTest,
		"python-plain": pythonPlainTest,
		"python-pyproject": pythonPyprojectTest,
		"ruby-plain": rubyPlainTest,
		"rust-cargo": rustCargoTest,
		"rust-plain": rustPlainTest,
	};
};

export const testKind = async (kind: Kind) => {
	console.log(`testing ${kind}...`);
	const dirs = await testDirs();
	const source = dirs[kind];

	// Test detection
	console.log("source", source.id);
	const detectedKind = await detectKind(source);
	tg.assert(detectedKind == kind, `expected ${kind}, got ${detectedKind}`);

	// Test build
	const buildOutput = await build({ source }).then(tg.Directory.expect);
	console.log("buildOutput", buildOutput.id);
	const testStdout = async (arg: TestFnArg): Promise<boolean> => {
		const stdout = await $`${arg.testFile(buildOutput)} > $OUTPUT`
			.then(tg.File.expect)
			.then((t) => t.text())
			.then((t) => t.trim());
		tg.assert(
			stdout === arg.expectedStdout,
			`expected ${arg.expectedStdout}, received ${stdout}`,
		);
		return true;
	};
	await testStdout(testParamaters()[kind]);
	return true;
};
